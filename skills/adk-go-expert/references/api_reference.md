# ADK-Go API 参考

## 1. 概述

本文档提供了 ADK-Go 框架的核心 API 参考，包括主要接口、结构体、函数和方法。API 按照包或模块组织，便于查阅和使用。

## 2. agent 包

### 2.1 概述

`agent` 包定义了代理框架的核心接口和类型，是 ADK-Go 框架的基础。

### 2.2 Agent 接口

```go
type Agent interface {
    Name() string
    Description() string
    Run(InvocationContext) iter.Seq2[*Event, error]
    SubAgents() []Agent
    internal() *agent
}
```

**描述**：
Agent 接口是所有代理的基本抽象，定义了代理的核心行为。

**方法说明**：
- `Name() string`：返回代理的名称
- `Description() string`：返回代理的描述
- `Run(InvocationContext) iter.Seq2[*Event, error]`：运行代理，接收上下文并返回事件迭代器
- `SubAgents() []Agent`：返回代理的子代理列表
- `internal() *agent`：返回内部代理实现（内部使用）

### 2.3 InvocationContext 接口

```go
type InvocationContext interface {
    Done() context.Context
    Agent() Agent
    Session() session.Session
    Artifacts() artifact.Service
    Memory() memory.Service
    UserContent() *genai.Content
    RunConfig() RunConfig
    Branch() string
    InvocationID() string
    NewInvocationID() string
}
```

**描述**：
InvocationContext 提供了代理运行时的上下文信息。

**方法说明**：
- `Done() context.Context`：返回上下文的 done 通道
- `Agent() Agent`：返回当前代理
- `Session() session.Session`：返回当前会话
- `Artifacts() artifact.Service`：返回制品服务
- `Memory() memory.Service`：返回内存服务
- `UserContent() *genai.Content`：返回用户内容
- `RunConfig() RunConfig`：返回运行配置
- `Branch() string`：返回当前分支
- `InvocationID() string`：返回当前调用 ID
- `NewInvocationID() string`：生成新的调用 ID

### 2.4 RunConfig 结构体

```go
type RunConfig struct {
    // MaxTokens limits the maximum number of tokens generated by the agent.
    MaxTokens int
    // Temperature controls the randomness of the generated output.
    Temperature float64
    // TopP controls the diversity of the generated output.
    TopP float64
    // TopK controls the diversity of the generated output.
    TopK int
}
```

**描述**：
RunConfig 定义了代理运行时的配置参数。

### 2.5 New 函数

```go
func New(cfg Config) (Agent, error)
```

**描述**：
创建一个新的自定义代理。

**参数**：
- `cfg`：代理配置

**返回值**：
- `Agent`：创建的代理
- `error`：可能的错误

### 2.6 Config 结构体

```go
type Config struct {
    // Name is the name of the agent.
    Name string
    // Description is the description of the agent.
    Description string
    // SubAgents is a list of sub-agents that this agent can use.
    SubAgents []Agent
    // Run is the function that implements the agent's behavior.
    Run func(InvocationContext) iter.Seq2[*Event, error]
    // BeforeAgentCallbacks are callbacks that are called before the agent runs.
    BeforeAgentCallbacks []BeforeAgentCallback
    // AfterAgentCallbacks are callbacks that are called after the agent runs.
    AfterAgentCallbacks []AfterAgentCallback
}
```

**描述**：
Config 用于配置代理的创建。

## 3. agent/llmagent 包

### 3.1 概述

`llmagent` 包提供了基于 LLM（大语言模型）的代理实现。

### 3.2 New 函数

```go
func New(cfg Config) (agent.Agent, error)
```

**描述**：
创建一个新的 LLM 代理。

**参数**：
- `cfg`：LLM 代理配置

**返回值**：
- `agent.Agent`：创建的 LLM 代理
- `error`：可能的错误

### 3.3 Config 结构体

```go
type Config struct {
    // Basic agent configuration.
    agent.Config
    // Model is the name of the LLM model to use.
    Model string
    // Instruction is the system instruction for the LLM.
    Instruction string
    // Tools are the tools that the agent can use.
    Tools []tool.Tool
    // Temperature controls the randomness of the generated output.
    Temperature float64
    // TopP controls the diversity of the generated output.
    TopP float64
    // TopK controls the diversity of the generated output.
    TopK int
    // MaxTokens limits the maximum number of tokens generated by the model.
    MaxTokens int
    // BeforeModelCallbacks are callbacks that are called before the model is invoked.
    BeforeModelCallbacks []BeforeModelCallback
    // AfterModelCallbacks are callbacks that are called after the model is invoked.
    AfterModelCallbacks []AfterModelCallback
    // BeforeToolCallbacks are callbacks that are called before a tool is invoked.
    BeforeToolCallbacks []BeforeToolCallback
    // AfterToolCallbacks are callbacks that are called after a tool is invoked.
    AfterToolCallbacks []AfterToolCallback
}
```

**描述**：
Config 用于配置 LLM 代理的创建。

## 4. agent/workflowagents 包

### 4.1 概述

`workflowagents` 包提供了多种工作流代理实现，用于编排多个子代理的执行。

### 4.2 sequentialagent 子包

#### 4.2.1 New 函数

```go
func New(cfg Config) (agent.Agent, error)
```

**描述**：
创建一个新的顺序代理，按顺序执行其子代理。

**参数**：
- `cfg`：顺序代理配置

**返回值**：
- `agent.Agent`：创建的顺序代理
- `error`：可能的错误

#### 4.2.2 Config 结构体

```go
type Config struct {
    // Basic agent configuration.
    agent.Config
}
```

**描述**：
Config 用于配置顺序代理的创建。

### 4.3 parallelagent 子包

#### 4.3.1 New 函数

```go
func New(cfg Config) (agent.Agent, error)
```

**描述**：
创建一个新的并行代理，并行执行其子代理。

**参数**：
- `cfg`：并行代理配置

**返回值**：
- `agent.Agent`：创建的并行代理
- `error`：可能的错误

#### 4.3.2 Config 结构体

```go
type Config struct {
    // Basic agent configuration.
    agent.Config
}
```

**描述**：
Config 用于配置并行代理的创建。

### 4.4 loopagent 子包

#### 4.4.1 New 函数

```go
func New(cfg Config) (agent.Agent, error)
```

**描述**：
创建一个新的循环代理，循环执行其子代理。

**参数**：
- `cfg`：循环代理配置

**返回值**：
- `agent.Agent`：创建的循环代理
- `error`：可能的错误

#### 4.4.2 Config 结构体

```go
type Config struct {
    // Basic agent configuration.
    agent.Config
    // MaxIterations limits the maximum number of iterations.
    // If MaxIterations == 0, then LoopAgent runs indefinitely or until any sub-agent escalates.
    MaxIterations uint
}
```

**描述**：
Config 用于配置循环代理的创建。

## 5. agent/remoteagent 包

### 5.1 概述

`remoteagent` 包提供了远程代理的实现，支持 A2A（Agent-to-Agent）协议。

### 5.2 A2AConfig 结构体

```go
type A2AConfig struct {
    // Basic agent configuration.
    agent.Config
    // AgentCard is the agent card for the remote agent.
    AgentCard *a2a.AgentCard
    // AgentCardSource is the source of the agent card.
    AgentCardSource string
    // Converter is used to convert between ADK events and A2A events.
    Converter A2AEventConverter
    // AfterRequestCallbacks are called after receiving a response from the remote agent.
    AfterRequestCallbacks []AfterA2ARequestCallback
    // AfterAgentCallbacks are called after the agent has completed its run.
    AfterAgentCallbacks []agent.AfterAgentCallback
    // ClientFactory is used to create A2A clients.
    ClientFactory *a2aclient.Factory
    // MessageSendConfig is attached to a2a.MessageSendParams sent on every agent invocation.
    MessageSendConfig *a2a.MessageSendConfig
}
```

**描述**：
A2AConfig 用于配置远程代理的创建。

### 5.3 NewA2A 函数

```go
func NewA2A(cfg A2AConfig) (agent.Agent, error)
```

**描述**：
创建一个新的远程 A2A 代理。

**参数**：
- `cfg`：A2A 代理配置

**返回值**：
- `agent.Agent`：创建的 A2A 代理
- `error`：可能的错误

## 6. runner 包

### 6.1 概述

`runner` 包提供了代理运行器的实现，负责代理的生命周期管理、会话管理和事件处理。

### 6.2 Runner 结构体

```go
type Runner struct {
    // 内部字段，不直接暴露给用户
}
```

**描述**：
Runner 是代理的运行和管理器。

### 6.3 New 函数

```go
func New(cfg Config) (*Runner, error)
```

**描述**：
创建一个新的运行器。

**参数**：
- `cfg`：运行器配置

**返回值**：
- `*Runner`：创建的运行器
- `error`：可能的错误

### 6.4 Config 结构体

```go
type Config struct {
    // AppName is the name of the application.
    AppName string
    // RootAgent is the root agent for the runner.
    RootAgent agent.Agent
    // SessionService is the session service to use.
    SessionService session.Service
    // ArtifactService is the artifact service to use.
    ArtifactService artifact.Service
    // MemoryService is the memory service to use.
    MemoryService memory.Service
    // Monitor is the monitor to use for collecting metrics.
    Monitor monitor.Monitor
}
```

**描述**：
Config 用于配置运行器的创建。

### 6.5 Run 方法

```go
func (r *Runner) Run(ctx context.Context, userID string, sessionID string, content *genai.Content, cfg *agent.RunConfig) iter.Seq2[*Event, error]
```

**描述**：
运行代理，处理用户请求并返回事件迭代器。

**参数**：
- `ctx`：上下文
- `userID`：用户 ID
- `sessionID`：会话 ID
- `content`：用户内容
- `cfg`：代理运行配置

**返回值**：
- `iter.Seq2[*Event, error]`：事件迭代器

## 7. session 包

### 7.1 概述

`session` 包提供了会话管理的实现，用于管理代理与用户的交互会话。

### 7.2 Session 接口

```go
type Session interface {
    ID() string
    UserID() string
    State() map[string]any
    SetState(map[string]any)
    AddEvent(*Event)
    Events() []*Event
    CreatedAt() time.Time
    UpdatedAt() time.Time
}
```

**描述**：
Session 接口定义了会话的核心行为。

**方法说明**：
- `ID() string`：返回会话 ID
- `UserID() string`：返回用户 ID
- `State() map[string]any`：返回会话状态
- `SetState(map[string]any)`：设置会话状态
- `AddEvent(*Event)`：添加事件到会话
- `Events() []*Event`：返回会话事件列表
- `CreatedAt() time.Time`：返回会话创建时间
- `UpdatedAt() time.Time`：返回会话更新时间

### 7.3 Event 结构体

```go
type Event struct {
    ID           string
    Content      *genai.Content
    Author       string
    Timestamp    time.Time
    Actions      Actions
    ArtifactIDs  []string
    InvocationID string
    Branch       string
    Parent       string
}
```

**描述**：
Event 表示会话中的一个事件。

### 7.4 Actions 结构体

```go
type Actions struct {
    Escalate bool
    Transfer string
    Final    bool
    Error    string
}
```

**描述**：
Actions 表示事件的操作。

### 7.5 Service 接口

```go
type Service interface {
    Create(ctx context.Context, userID string, state map[string]any) (Session, error)
    Get(ctx context.Context, sessionID string) (Session, error)
    Save(ctx context.Context, session Session) error
    Delete(ctx context.Context, sessionID string) error
    List(ctx context.Context, userID string, filter ListFilter) ([]Session, error)
}
```

**描述**：
Service 接口定义了会话服务的核心行为。

**方法说明**：
- `Create(ctx context.Context, userID string, state map[string]any) (Session, error)`：创建会话
- `Get(ctx context.Context, sessionID string) (Session, error)`：获取会话
- `Save(ctx context.Context, session Session) error`：保存会话
- `Delete(ctx context.Context, sessionID string) error`：删除会话
- `List(ctx context.Context, userID string, filter ListFilter) ([]Session, error)`：列出会话

## 8. tool 包

### 8.1 概述

`tool` 包提供了工具系统的实现，用于扩展代理的能力。

### 8.2 Tool 接口

```go
type Tool interface {
    Name() string
    Description() string
    IsLongRunning() bool
    Invoke(ctx context.Context, args json.RawMessage) (any, error)
}
```

**描述**：
Tool 接口定义了工具的核心行为。

**方法说明**：
- `Name() string`：返回工具名称
- `Description() string`：返回工具描述
- `IsLongRunning() bool`：返回工具是否为长时间运行的任务
- `Invoke(ctx context.Context, args json.RawMessage) (any, error)`：调用工具，接收上下文和参数，返回结果和可能的错误

### 8.3 NewTool 函数

```go
func NewTool(cfg ToolConfig) Tool
```

**描述**：
创建一个新的工具。

**参数**：
- `cfg`：工具配置

**返回值**：
- `Tool`：创建的工具

### 8.4 ToolConfig 结构体

```go
type ToolConfig struct {
    // Name is the name of the tool.
    Name string
    // Description is the description of the tool.
    Description string
    // IsLongRunning indicates whether the tool is long-running.
    IsLongRunning bool
    // Invoke is the function that implements the tool's behavior.
    Invoke func(ctx context.Context, args json.RawMessage) (any, error)
}
```

**描述**：
ToolConfig 用于配置工具的创建。

## 9. artifact 包

### 9.1 概述

`artifact` 包提供了制品服务的实现，用于管理代理生成和使用的制品。

### 9.2 Service 接口

```go
type Service interface {
    Create(ctx context.Context, artifact *Artifact) (*Artifact, error)
    Get(ctx context.Context, id string) (*Artifact, error)
    List(ctx context.Context, filter Filter) ([]*Artifact, error)
    Update(ctx context.Context, artifact *Artifact) (*Artifact, error)
    Delete(ctx context.Context, id string) error
}
```

**描述**：
Service 接口定义了制品服务的核心行为。

**方法说明**：
- `Create(ctx context.Context, artifact *Artifact) (*Artifact, error)`：创建制品
- `Get(ctx context.Context, id string) (*Artifact, error)`：获取制品
- `List(ctx context.Context, filter Filter) ([]*Artifact, error)`：列出制品
- `Update(ctx context.Context, artifact *Artifact) (*Artifact, error)`：更新制品
- `Delete(ctx context.Context, id string) error`：删除制品

### 9.3 Artifact 结构体

```go
type Artifact struct {
    ID          string
    Name        string
    Type        string
    Content     []byte
    SessionID   string
    UserID      string
    CreatedAt   time.Time
    UpdatedAt   time.Time
    Metadata    map[string]any
}
```

**描述**：
Artifact 表示一个制品。

### 9.4 Filter 结构体

```go
type Filter struct {
    SessionID string
    UserID    string
    Type      string
    Name      string
}
```

**描述**：
Filter 用于过滤制品列表。

## 10. memory 包

### 10.1 概述

`memory` 包提供了内存服务的实现，用于管理代理的内存。

### 10.2 Service 接口

```go
type Service interface {
    Write(ctx context.Context, memory *Memory) (*Memory, error)
    Read(ctx context.Context, id string) (*Memory, error)
    Query(ctx context.Context, query string) ([]*Memory, error)
    Delete(ctx context.Context, id string) error
}
```

**描述**：
Service 接口定义了内存服务的核心行为。

**方法说明**：
- `Write(ctx context.Context, memory *Memory) (*Memory, error)`：写入内存
- `Read(ctx context.Context, id string) (*Memory, error)`：读取内存
- `Query(ctx context.Context, query string) ([]*Memory, error)`：查询内存
- `Delete(ctx context.Context, id string) error`：删除内存

### 10.3 Memory 结构体

```go
type Memory struct {
    ID          string
    Type        string
    Content     string
    SessionID   string
    UserID      string
    CreatedAt   time.Time
    UpdatedAt   time.Time
    Metadata    map[string]any
}
```

**描述**：
Memory 表示一个内存条目。

## 11. server 包

### 11.1 概述

`server` 包提供了服务器实现，用于暴露代理服务。

### 11.2 rest 子包

#### 11.2.1 New 函数

```go
func New(runner *runner.Runner) *Server
```

**描述**：
创建一个新的 REST 服务器。

**参数**：
- `runner`：代理运行器

**返回值**：
- `*Server`：创建的 REST 服务器

#### 11.2.2 Server 结构体

```go
type Server struct {
    // 内部字段，不直接暴露给用户
}
```

**描述**：
Server 表示 REST 服务器。

#### 11.2.3 Run 方法

```go
func (s *Server) Run(cfg RunConfig) error
```

**描述**：
运行 REST 服务器。

**参数**：
- `cfg`：服务器运行配置

**返回值**：
- `error`：可能的错误

#### 11.2.4 RunConfig 结构体

```go
type RunConfig struct {
    // Port is the port to listen on.
    Port int
    // TLSConfig is the TLS configuration to use.
    TLSConfig *tls.Config
}
```

**描述**：
RunConfig 用于配置 REST 服务器的运行。

#### 11.2.5 AddHealthCheckHandler 方法

```go
func (s *Server) AddHealthCheckHandler(path string, check func() bool)
```

**描述**：
添加健康检查端点。

**参数**：
- `path`：健康检查路径
- `check`：健康检查函数

## 12. model 包

### 12.1 概述

`model` 包提供了 LLM 模型的集成，用于连接和使用各种 LLM 模型。

### 12.2 LLM 接口

```go
type LLM interface {
    Generate(ctx context.Context, req *GenerateRequest) (*GenerateResponse, error)
}
```

**描述**：
LLM 接口定义了 LLM 模型的核心行为。

**方法说明**：
- `Generate(ctx context.Context, req *GenerateRequest) (*GenerateResponse, error)`：生成文本

### 12.3 GenerateRequest 结构体

```go
type GenerateRequest struct {
    Content      *genai.Content
    Temperature  float64
    TopP         float64
    TopK         int
    MaxTokens    int
    Tools        []tool.Tool
    ToolChoice   any
}
```

**描述**：
GenerateRequest 表示生成请求。

### 12.4 GenerateResponse 结构体

```go
type GenerateResponse struct {
    Content      *genai.Content
    Usage        Usage
    ToolCalls    []ToolCall
    FinishReason string
}
```

**描述**：
GenerateResponse 表示生成响应。

### 12.5 Usage 结构体

```go
type Usage struct {
    PromptTokens     int
    CompletionTokens int
    TotalTokens      int
}
```

**描述**：
Usage 表示模型使用情况。

### 12.6 ToolCall 结构体

```go
type ToolCall struct {
    Name      string
    Args      json.RawMessage
    ID        string
    Type      string
    Thought   string
}
```

**描述**：
ToolCall 表示工具调用。

## 13. 示例代码

### 13.1 创建和运行 LLM 代理

```go
// 创建 LLM 代理
llmAgent, err := llmagent.New(llmagent.Config{
    Name:        "llm-assistant",
    Description: "A helpful LLM assistant",
    Model:       "gemini-1.5-pro",
    Instruction: "You are a helpful assistant.",
})
if err != nil {
    panic(err)
}

// 创建运行器
runner, err := runner.New(runner.Config{
    AppName:   "my-app",
    RootAgent: llmAgent,
})
if err != nil {
    panic(err)
}

// 运行代理
content := genai.NewContentFromText("Hello, world!")
for event, err := range runner.Run(context.Background(), "user-123", "session-456", content, nil) {
    if err != nil {
        panic(err)
    }
    fmt.Printf("Event: %v\n", event)
}
```

### 13.2 创建和运行工作流代理

```go
// 创建多个子代理
agent1, _ := llmagent.New(llmagent.Config{Name: "agent-1", Model: "gemini-1.5-pro"})
agent2, _ := llmagent.New(llmagent.Config{Name: "agent-2", Model: "gemini-1.5-pro"})
agent3, _ := llmagent.New(llmagent.Config{Name: "agent-3", Model: "gemini-1.5-pro"})

// 创建顺序代理
sequentialAgent, _ := sequentialagent.New(sequentialagent.Config{
    AgentConfig: agent.Config{
        Name:      "sequential-agent",
        SubAgents: []agent.Agent{agent1, agent2, agent3},
    },
})

// 创建运行器
runner, _ := runner.New(runner.Config{AppName: "my-app", RootAgent: sequentialAgent})

// 运行代理
content := genai.NewContentFromText("Hello, workflow!")
for event, err := range runner.Run(context.Background(), "user-123", "session-456", content, nil) {
    if err != nil {
        panic(err)
    }
    fmt.Printf("Event: %v\n", event)
}
```

### 13.3 创建和使用自定义工具

```go
// 创建自定义工具
calculatorTool := &CalculatorTool{}

// 创建带有工具的 LLM 代理
llmAgent, _ := llmagent.New(llmagent.Config{
    Name:        "llm-assistant-with-tools",
    Model:       "gemini-1.5-pro",
    Instruction: "You are a helpful assistant. Use the calculator tool for arithmetic operations.",
    Tools:       []tool.Tool{calculatorTool},
})

// 创建运行器
runner, _ := runner.New(runner.Config{AppName: "my-app", RootAgent: llmAgent})

// 运行代理
content := genai.NewContentFromText("What is 2 + 2?")
for event, err := range runner.Run(context.Background(), "user-123", "session-456", content, nil) {
    if err != nil {
        panic(err)
    }
    fmt.Printf("Event: %v\n", event)
}
```

## 14. 最佳实践

### 14.1 API 使用最佳实践

- **使用适当的代理类型**：根据任务需求选择合适的代理类型，如 LLM 代理、工作流代理或远程代理

- **合理配置代理**：根据任务需求配置代理参数，如温度、TopP、TopK 等

- **使用适当的工具**：为代理提供必要的工具，避免过多无用工具

- **实现适当的错误处理**：处理代理运行过程中可能出现的错误

- **监控代理运行**：监控代理的运行状态和性能指标

### 14.2 代码组织最佳实践

- **模块化设计**：将复杂代理分解为多个简单代理

- **清晰的命名**：为代理、工具和变量使用清晰、描述性的名称

- **适当的注释**：为代码添加适当的注释，说明代理的功能和行为

- **测试驱动开发**：为代理和工具编写单元测试，确保其正确性
